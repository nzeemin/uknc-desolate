
; Put background tile on the screen, 16x16 -> 16x16 on shadow screen, no mask
;   R3 = row; R2 = tile column 0..11; R4 = tile address
L9EAD:
	ADD	R2, R2
	ADD	R2, R2
	ADD	R2, R2
	ADD	R2, R2
	MOVB	R2, @#L86D7		; penCol
	MOV	R3, R0			; penRow
	CALL	GSADDR			; now R3 = screen addr
	MOV	#8., R1			; 8 row pairs
L9EAD1:
; Draw 1st line
	MOVB	(R4)+, (R3)+
	MOVB	(R4)+, (R3)
	ADD	#<24.-1>, R3
; Draw 2nd line
	MOVB	(R4)+, (R3)+
	MOVB	(R4)+, (R3)
	ADD	#<24.-1>, R3
; Continue the loop
	SOB	R1, L9EAD1
	RETURN

; Copy shadow screen to UKNC screen
;
L9FEA=SHOWSC

; Clear shadow screen
; 128+10 lines, 24 8px columns; 24 * 138 = 3312 bytes
CLSHAD:
L9FCF:	MOV	#138., R1		; 24 * 138 = 3312
	MOV	#SHADOW, R3
L9FCF1:	CLR	(R3)+			; bytes 0-1
	CLR	(R3)+			; 2-3
	CLR	(R3)+			; 4-5
	CLR	(R3)+			; 6-7
	CLR	(R3)+			; 8-9
	CLR	(R3)+			; 10-11
	CLR	(R3)+			; 12-13
	CLR	(R3)+			; 14-15
	CLR	(R3)+			; 16-17
	CLR	(R3)+			; 18-19
	CLR	(R3)+			; 20-21
	CLR	(R3)+			; 22-23
	SOB	R1, L9FCF1
	RETURN

; Scan keyboard
; Returns key in A; Z=0 for key, Z=1 for no key
;
LA0F1:
;TODO
	RETURN

; Display 96 tiles on the screen with background tiles (Tileset1)
;   R3 = Address where the 96 tiles are placed
LA88F:
	CLR	R1		; col
	CLR	R2		; row
LA892:	PUSH	R1
	PUSH	R3
	PUSH	R2
	MOVB	(R3), R4
	BEQ	LA8B0		; empty tile? => skip it
	CMP	R4, #107	; menu background tile?
	BNE	LA8921
	CALL	LBC29		; add phase
LA8921:	ADD	R4, R4
	ADD	R4, R4
	ADD	R4, R4
	ADD	R4, R4
	ADD	R4, R4		; now R4 = tile * 32
	ADD	#TILES1, R4
	MOV	R2, R3		; row
	MOV	R1, R2		; col
	CALL	L9EAD		; Put tile; R3 = row; R2 = col; R4 = tile address
LA8B0:	POP	R2
	POP	R3
	POP	R1
	INC	R3		; next tile
	INC	R1		; next col
	CMP	R1, #12.	; was last column?
	BNE	LA892		; no => continue the loop
	CLR	R1
	ADD	#16., R2	; next row
	CMPB	#128., R2	; was last tile row?
	BNE	LA892		; no => continue the loop
	RETURN
;
LA8C6:
	CLR	@#LDD54			; clear animation phase
;
; Draw Player tiles
LA8CD:
;TODO
	RETURN

;
; Show small message popup
LAB28:
	PUSH	R1
	PUSh	R2
	MOV	#LEB27, R3	; Decode from: Small message popup
	CALL	LADEE		; Decode 96 bytes of the screen to LDBF5
	CALL	LB177		; Display screen HL from tiles with Tileset2
	POP	R2
	POP	R1
	RETURN

; Decode current room to LDBF5
;   Returns: R3 = LDBF5
LADE5:
	MOVB	@#LDB79, R0	; Get the room number
	MOV	#LDE97, R3	; List of encoded room addresses
	CALL	LADFF		; now R3 = encoded room address
; Entry point: Decode 96 bytes to LDBF5
LADEE:
	MOV	#96., R1	; decode 96 bytes
; Decode the room/screen to LDBF5
;   R3 = decode from; R1 = tile count to decode
;   Returns: R3 = LDBF5
LADF5:
	MOV	#LDBF5, R2
	CALL	LB9F1		; Decode the room/screen
	MOV	#LDBF5, R3
	RETURN
;
; Get address from table
;   R0 = Element number
;   R3 = Table address
LADFF:
	ADD	R0, R0
	ADD	R0, R3
	MOV	(R3), R3
	RETURN
;
; Decode current room description to LDBF5
;   Returns: R3 = LDBF5
LAE09:
	MOVB	@#LDB79, R0	; Get room number
	MOV	#LDF27, R3	; Table of adresses for room descriptions
	CALL	LADFF		; Get address from table by index A
	MOV	#49., R1	; decode 49 bytes
	BR	LADF5		; Decode the room/screen to LDBF5

;
; Open the Inventory pop-up
;
LB0A2:
	MOV	#LF329, R3	; Encoded screen for Inventory/Info popup
	CALL	LADEE		; Decode 96 bytes of the screen to LDBF5
	CALL	LB177		; Display screen HL from tiles with Tileset 2
	MOVB	#22., @#LDCF3	; Left margin size for text
	MOVB	#12., @#LDCF4	; Line interval for text
	CLRB	@#LDCF5		; Data cartridge reader slot??
	CLRB	@#LDC59		; set delay factor
	CLRB	@#LDC5A		; clear Inventory items count
	CLRB	@#LDCF8
	MOVB	#16., @#LDC83	; set X pos
	MOVB	#24., @#LDC84	; set Y pos
	MOV	#13060, @#L86D7	; Set penRow/penCol
	MOV	#SE0BB, R3	; "- INVENTORY -"
	CALL	DRSTR
	MOV	#LDB9C, R3
	MOV	#29., R1
LB0E0:				; loop by B
;TODO
	RETURN

LBC29:
;TODO
	RETURN

; Display screen from tiles with Tileset2
;   R3 = Screen in tiles, usually LDBF5
LB177:
	CLR	R1		; col
	CLR	R2		; row
LB1770:
	PUSH	R1
	PUSH	R2
	MOVB	(R3)+, R4
	PUSH	R3		; store tile address
	CMPB	#001, R4
	BEQ	LB1771
	ADD	R4, R4
	ADD	R4, R4
	ADD	R4, R4
	ADD	R4, R4
	ADD	R4, R4
	ADD	R4, R4		; now R4 = tile * 64
	ADD	#TILES2, R4	; R4 = tile address
	MOV	R2, R3		; row
	MOV	R1, R2		; col
	CALL	DRTIL2		; Draw tile from Tileset2; R3 = row, R2 = col, R4 = tile addr
LB1771:	POP	R3		; restore tile address
	POP	R2		; restore row
	POP	R1		; restore col
	ADD	#16., R1	; next col
	CMP	R1, #<16.*12.>	; end of line?
	BNE	LB1770		; no => continue the loop
	CLR	R1
	ADD	#16., R2	; next row
	CMPB	#128., R2	; last row?
	BNE	LB1770		; no => continue the loop
	RETURN

; Delay by LDC59
LB2D0:
;TODO
	RETURN

; Decode the block from RLE sequence
;   R3 = address decode from (usually encoded room/screen)
;   R2 = address decode to
;   R1 = number of bytes to decode
LB9F1:	MOVB	(R3)+, R0
	CMPB	R0, #377	; repeater?
	BEQ	LB9F13
	MOVB	R0, (R2)+
	SOB	R1, LB9F1
LB9F11:	RETURN
LB9F13:	MOVB	(R3)+, R0
	BIC	#177400, R0
	INC	R3
LB9F14:	DEC	R3
	MOVB	(R3)+, (R2)+
	DEC	R1
	BEQ	LB9F11
	SOB	R0, LB9F14
	BR	LB9F1

; Draw string on the screen
;   R3 = String address
LBEDE:
	MOVB	(R3)+, R0
	BNE	LBEDE1
	RETURN
LBEDE1:	CMPB	R0, #174	; CP 7Ch	; '|' - line end ?
	BEQ	LBF1B
	PUSH	R3
	CALL	DRCHAR
	MOVB	@#LDC85, R0		; get Delay and copy screen flag
	BEQ	LBEF91
	CALL	LB2D0			; Delay
	CALL	SHOWSC			; Copy shadow screen to UKNC screen
LBEF91:
	POP	R3
	BR	LBEDE
LBF1B:					; Line end
	PUSH	R1
	MOVB	@#L86D8, R1		; Get penRow 0..127
	MOVB	@#LDCF4, R0		; Line interval for text
	ADD	R1, R0
	MOVB	R0, @#L86D8		; Set penRow
	MOVB	@#LDCF3, @#L86D7	; Get left margin size for text -> set penCol
	POP	R1
	BR	LBEDE

	RETURN
